{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/Pivot%20Hackathon/l-T-SRCAS-hack/components/DodgeHero.tsx"],"sourcesContent":["\"use client\"\n\nimport { motion, AnimatePresence } from \"framer-motion\"\nimport { useRef, useState, MouseEvent, useEffect, useCallback } from \"react\"\n\ntype Position = {\n    x: number\n    y: number\n}\n\n// Witty troll messages that appear when user tries to catch the note\nconst trollMessages = [\n    \"Too slow! üòú\",\n    \"Almost got me!\",\n    \"Nice try! üèÉ\",\n    \"Gotta be faster!\",\n    \"Nope! üòÑ\",\n    \"Keep trying!\",\n    \"So close!\",\n    \"Can't catch me! üéØ\",\n    \"Better luck next time!\",\n    \"I'm too quick! ‚ö°\",\n    \"Haha, missed!\",\n    \"Getting tired? üòè\",\n    \"Keep up!\",\n    \"Is that all you got?\",\n    \"Try harder! üí™\",\n]\n\nconst DodgeHero: React.FC = () => {\n    const containerRef = useRef<HTMLDivElement | null>(null)\n    const [pos, setPos] = useState<Position>({ x: 0, y: 0 })\n    const [message, setMessage] = useState<string>(\"Click to Register! üéØ\")\n    const [showTroll, setShowTroll] = useState<boolean>(false)\n    const [trollText, setTrollText] = useState<string>(\"\")\n    const [dodgeCount, setDodgeCount] = useState<number>(0)\n    const [isCaught, setIsCaught] = useState<boolean>(false)\n    const [difficulty, setDifficulty] = useState<number>(1)\n    const lastDodgeTime = useRef<number>(0)\n\n    // Increase difficulty as user gets closer to winning\n    useEffect(() => {\n        if (dodgeCount > 5) setDifficulty(1.2)\n        if (dodgeCount > 10) setDifficulty(1.4)\n        if (dodgeCount > 15) setDifficulty(1.6)\n        if (dodgeCount > 20) setDifficulty(1.8)\n    }, [dodgeCount])\n\n    // Reset position after some time (but make it harder by resetting faster to center)\n    useEffect(() => {\n        if (pos.x !== 0 || pos.y !== 0) {\n            const timer = setTimeout(() => {\n                if (!isCaught) {\n                    // Move to a random position instead of center to be unpredictable\n                    const randomX = (Math.random() - 0.5) * 150\n                    const randomY = (Math.random() - 0.5) * 100\n                    setPos({ x: randomX, y: randomY })\n                    setMessage(\"Come on, catch me! üéØ\")\n                }\n            }, 1500)\n            return () => clearTimeout(timer)\n        }\n    }, [pos, isCaught])\n\n    // Predictive dodge - anticipate where mouse is going\n    const handleMouseMove = useCallback((e: MouseEvent<HTMLDivElement>) => {\n        if (!containerRef.current || isCaught) return\n\n        const now = Date.now()\n        // Cooldown to prevent too rapid dodges (but very short!)\n        if (now - lastDodgeTime.current < 50) return\n\n        const rect = containerRef.current.getBoundingClientRect()\n        const noteElement = containerRef.current.querySelector('.dodge-note')\n        if (!noteElement) return\n\n        const noteRect = noteElement.getBoundingClientRect()\n        const noteCenterX = noteRect.left + noteRect.width / 2\n        const noteCenterY = noteRect.top + noteRect.height / 2\n\n        const dx = e.clientX - noteCenterX\n        const dy = e.clientY - noteCenterY\n        const distance = Math.sqrt(dx * dx + dy * dy)\n\n        // MUCH larger detection radius - starts dodging from far away!\n        const detectionRadius = 250 * difficulty\n\n        if (distance < detectionRadius) {\n            lastDodgeTime.current = now\n\n            const angle = Math.atan2(dy, dx)\n\n            // Bigger dodge distance that scales with difficulty\n            const baseDodge = 300\n            const randomFactor = 100\n            const dodgeDistance = (baseDodge + Math.random() * randomFactor) * difficulty\n\n            // Add some unpredictability - sometimes dodge perpendicular!\n            const perpendicular = Math.random() > 0.7 ? (Math.PI / 2) * (Math.random() > 0.5 ? 1 : -1) : 0\n            const finalAngle = angle + perpendicular\n\n            // Keep within bounds - larger area now\n            const maxX = rect.width / 2 - 180\n            const maxY = rect.height / 2 - 150\n\n            // Calculate new position with momentum from previous position\n            let newX = -Math.cos(finalAngle) * dodgeDistance + pos.x * 0.5\n            let newY = -Math.sin(finalAngle) * dodgeDistance + pos.y * 0.5\n\n            // Bounce off walls with extra randomness\n            if (Math.abs(newX) > maxX) {\n                newX = Math.sign(newX) * maxX * (0.7 + Math.random() * 0.3)\n                // Add vertical juke when hitting horizontal wall\n                newY += (Math.random() - 0.5) * 200\n            }\n            if (Math.abs(newY) > maxY) {\n                newY = Math.sign(newY) * maxY * (0.7 + Math.random() * 0.3)\n                // Add horizontal juke when hitting vertical wall\n                newX += (Math.random() - 0.5) * 200\n            }\n\n            // Final clamp\n            newX = Math.max(-maxX, Math.min(maxX, newX))\n            newY = Math.max(-maxY, Math.min(maxY, newY))\n\n            setPos({ x: newX, y: newY })\n\n            // Show troll message\n            const randomMessage = trollMessages[Math.floor(Math.random() * trollMessages.length)]\n            setTrollText(randomMessage)\n            setShowTroll(true)\n            setDodgeCount(prev => prev + 1)\n\n            // Update message based on attempts\n            if (dodgeCount < 5) {\n                setMessage(\"You can't catch me! üòú\")\n            } else if (dodgeCount < 10) {\n                setMessage(\"Still trying? üòè\")\n            } else if (dodgeCount < 15) {\n                setMessage(\"Getting desperate! ü§£\")\n            } else if (dodgeCount < 20) {\n                setMessage(\"Almost gave up? üí™\")\n            } else {\n                setMessage(\"Okay okay... üòÖ\")\n            }\n\n            // Hide troll message after delay\n            setTimeout(() => setShowTroll(false), 600)\n\n            // After MANY attempts (25+), let them catch it\n            if (dodgeCount > 24) {\n                setIsCaught(true)\n                setPos({ x: 0, y: 0 })\n                setMessage(\"Alright, you got me! üéâ\")\n            }\n        }\n    }, [dodgeCount, difficulty, isCaught, pos.x, pos.y])\n\n    const handleClick = () => {\n        if (isCaught || dodgeCount > 24) {\n            // Redirect to registration or scroll to register section\n            window.location.href = \"#register\"\n        }\n    }\n\n    return (\n        // Hidden on mobile (md:flex), full screen height, desktop only\n        <section\n            ref={containerRef}\n            onMouseMove={handleMouseMove}\n            className=\"hidden md:flex relative h-screen min-h-[800px] flex-col items-center justify-center overflow-hidden bg-gradient-to-b from-[#f8f5f0] to-[#f0ebe3]\"\n        >\n            {/* Decorative dot pattern - larger dots */}\n            <div className=\"absolute inset-0 opacity-30\">\n                <div\n                    className=\"absolute inset-0\"\n                    style={{\n                        backgroundImage: `radial-gradient(circle, #e8d4b8 10px, transparent 10px)`,\n                        backgroundSize: '80px 80px',\n                        backgroundPosition: '40px 40px',\n                    }}\n                />\n            </div>\n\n            {/* Main heading - BIGGER */}\n            <motion.div\n                initial={{ opacity: 0, y: -30 }}\n                animate={{ opacity: 1, y: 0 }}\n                transition={{ duration: 0.8 }}\n                className=\"text-center mb-16 relative z-10\"\n            >\n                <h2 className=\"text-5xl lg:text-7xl font-bold text-gray-800 mb-4\">\n                    Can you <span className=\"font-black italic\">catch</span> me ?!\n                </h2>\n                {/* <p className=\"text-gray-500 text-lg lg:text-xl\">\n                    {dodgeCount > 0\n                        ? `Attempts: ${dodgeCount} ${dodgeCount > 15 ? \"üî•\" : dodgeCount > 10 ? \"üí™\" : dodgeCount > 5 ? \"üò§\" : \"\"}`\n                        : \"Try to click the sticky note!\"}\n                </p> */}\n                {dodgeCount > 10 && !isCaught && (\n                    <motion.p\n                        initial={{ opacity: 0 }}\n                        animate={{ opacity: 1 }}\n                        className=\"text-sm text-gray-400 mt-2\"\n                    >\n                        Difficulty: {difficulty > 1.6 ? \"INSANE üî•\" : difficulty > 1.3 ? \"HARD üíÄ\" : \"Getting harder...\"}\n                    </motion.p>\n                )}\n            </motion.div>\n\n            {/* Dodging Sticky Note - BIGGER */}\n            <motion.div\n                className=\"dodge-note relative cursor-pointer select-none\"\n                animate={{\n                    x: pos.x,\n                    y: pos.y,\n                    rotate: isCaught ? 0 : (pos.x !== 0 ? -15 + Math.random() * 30 : -5),\n                    scale: isCaught ? 1.1 : 1,\n                }}\n                transition={{\n                    type: \"spring\",\n                    stiffness: 400,  // Faster spring\n                    damping: 15,     // Less damping = more bouncy\n                    mass: 0.5,       // Lighter = faster\n                }}\n                onClick={handleClick}\n                whileHover={isCaught ? { scale: 1.15 } : {}}\n            >\n                {/* Paper clip - BIGGER */}\n                <div className=\"absolute -top-6 right-6 w-8 h-14 z-20\">\n                    <svg viewBox=\"0 0 24 40\" fill=\"none\" className=\"w-full h-full\">\n                        <path\n                            d=\"M12 0 L12 8 C12 12 8 12 8 16 L8 32 C8 38 16 38 16 32 L16 12\"\n                            stroke=\"#9CA3AF\"\n                            strokeWidth=\"2\"\n                            fill=\"none\"\n                        />\n                    </svg>\n                </div>\n\n                {/* Sticky note - MUCH BIGGER */}\n                <div\n                    className=\"relative w-72 lg:w-80 bg-gradient-to-br from-[#fff9c4] to-[#ffeb3b] rounded-sm p-8 shadow-2xl\"\n                    style={{\n                        boxShadow: '6px 6px 25px rgba(0,0,0,0.25), inset 0 0 30px rgba(255,255,255,0.3)',\n                    }}\n                >\n                    {/* Folded corner effect - bigger */}\n                    <div\n                        className=\"absolute bottom-0 right-0 w-12 h-12\"\n                        style={{\n                            background: 'linear-gradient(135deg, transparent 50%, #f0e68c 50%)',\n                        }}\n                    />\n\n                    {/* Note content - BIGGER TEXT */}\n                    <div className=\"font-handwriting text-gray-700\">\n                        <p className=\"text-2xl lg:text-3xl font-bold italic mb-4 leading-tight\">\n                            {message}\n                        </p>\n                        {isCaught && (\n                            <motion.div\n                                initial={{ opacity: 0, scale: 0.8 }}\n                                animate={{ opacity: 1, scale: 1 }}\n                                className=\"mt-4\"\n                            >\n                                <p className=\"text-lg text-gray-600\">\n                                    Innovating for Tomorrow\n                                </p>\n                                <p className=\"text-base text-[#005CAA] font-semibold mt-2\">\n                                    PIVOT Hackathon 2026\n                                </p>\n                            </motion.div>\n                        )}\n                    </div>\n                </div>\n\n                {/* Troll message popup - BIGGER */}\n                <AnimatePresence>\n                    {showTroll && (\n                        <motion.div\n                            initial={{ opacity: 0, y: 10, scale: 0.8 }}\n                            animate={{ opacity: 1, y: -30, scale: 1 }}\n                            exit={{ opacity: 0, y: -40, scale: 0.8 }}\n                            className=\"absolute -top-12 left-1/2 -translate-x-1/2 whitespace-nowrap\"\n                        >\n                            <span className=\"bg-white px-4 py-2 rounded-full shadow-xl text-lg font-medium text-gray-700\">\n                                {trollText}\n                            </span>\n                        </motion.div>\n                    )}\n                </AnimatePresence>\n            </motion.div>\n\n            {/* Subtitle - BIGGER */}\n            <motion.div\n                initial={{ opacity: 0 }}\n                animate={{ opacity: 1 }}\n                transition={{ delay: 0.5 }}\n                className=\"mt-16 text-center relative z-10\"\n            >\n                <p className=\"text-gray-500 text-lg\">\n                    {isCaught\n                        ? \"Now click to register for the hackathon! üöÄ\"\n                        : dodgeCount > 15\n                            ? \"Don't give up! You're so close! üòà\"\n                            : dodgeCount > 8\n                                ? \"It's getting faster... üèÉüí®\"\n                                : \"Hover over the note to make it dodge!\"}\n                </p>\n            </motion.div>\n\n            {/* Decorative elements - BIGGER */}\n            <div className=\"absolute top-20 left-20 w-40 h-40 bg-[#005CAA]/5 rounded-full blur-3xl\" />\n            <div className=\"absolute bottom-20 right-20 w-56 h-56 bg-[#005CAA]/5 rounded-full blur-3xl\" />\n            <div className=\"absolute top-1/3 right-1/4 w-32 h-32 bg-[#FBA919]/5 rounded-full blur-2xl\" />\n        </section>\n    )\n}\n\nexport default DodgeHero\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 471, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/framer-motion/dist/es/utils/use-composed-ref.mjs","sources":["file:///D:/Pivot%20Hackathon/l-T-SRCAS-hack/node_modules/framer-motion/src/utils/use-composed-ref.ts"],"sourcesContent":["/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\nimport * as React from \"react\"\n\ntype PossibleRef<T> = React.Ref<T> | undefined\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T): void | (() => void) {\n    if (typeof ref === \"function\") {\n        return ref(value)\n    } else if (ref !== null && ref !== undefined) {\n        ;(ref as React.MutableRefObject<T>).current = value\n    }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    return (node) => {\n        let hasCleanup = false\n        const cleanups = refs.map((ref) => {\n            const cleanup = setRef(ref, node)\n            if (!hasCleanup && typeof cleanup === \"function\") {\n                hasCleanup = true\n            }\n            return cleanup\n        })\n        // React <19 will log an error to the console if a callback ref returns a\n        // value. We don't use ref cleanups internally so this will only happen if a\n        // user's ref callback returns a value, which we only expect if they are\n        // using the cleanup functionality added in React 19.\n        if (hasCleanup) {\n            return () => {\n                for (let i = 0; i < cleanups.length; i++) {\n                    const cleanup = cleanups[i]\n                    if (typeof cleanup === \"function\") {\n                        cleanup()\n                    } else {\n                        setRef(refs[i], null)\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs)\n}\n\nexport { useComposedRefs }\n"],"names":[],"mappings":";;;;;;AAAA;;CAEG,GAKH;;;CAGG,GACH,SAAS,MAAM,CAAI,GAAmB,EAAE,KAAQ,EAAA;IAC5C,IAAI,OAAO,GAAG,KAAK,UAAU,EAAE;QAC3B,OAAO,GAAG,CAAC,KAAK,CAAC,CAAA;KACpB,MAAM,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,SAAS,EAAE;QACxC,GAAiC,CAAC,OAAO,GAAG,KAAK,CAAA;KACtD;AACL,CAAC;AAED;;;CAGG,GACH,SAAS,WAAW,CAAI,GAAG,IAAsB,EAAA;IAC7C,OAAO,CAAC,IAAI,KAAI;QACZ,IAAI,UAAU,GAAG,KAAK,CAAA;QACtB,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,KAAI;YAC9B,MAAM,OAAO,GAAG,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAA;YACjC,IAAI,CAAC,UAAU,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;gBAC9C,UAAU,GAAG,IAAI,CAAA;aACpB;YACD,OAAO,OAAO,CAAA;QAClB,CAAC,CAAC,CAAA;;;;;QAKF,IAAI,UAAU,EAAE;YACZ,OAAO,MAAK;gBACR,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;oBACtC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;oBAC3B,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;wBAC/B,OAAO,EAAE,CAAA;qBACZ,MAAM;wBACH,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;qBACxB;iBACJ;YACL,CAAC,CAAA;SACJ;IACL,CAAC,CAAA;AACL,CAAC;AAED;;;CAGG,GACH,SAAS,eAAe,CAAI,GAAG,IAAsB,EAAA;;IAEjD,OAAO,KAAK,CAAC,8MAAW,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,EAAE,IAAI,CAAC,CAAA;AACxD"}},
    {"offset": {"line": 533, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs","sources":["file:///D:/Pivot%20Hackathon/l-T-SRCAS-hack/node_modules/framer-motion/src/components/AnimatePresence/PopChild.tsx"],"sourcesContent":["\"use client\"\n\nimport { isHTMLElement } from \"motion-dom\"\nimport * as React from \"react\"\nimport { useContext, useId, useInsertionEffect, useRef } from \"react\"\n\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { useComposedRefs } from \"../../utils/use-composed-ref\"\n\ninterface Size {\n    width: number\n    height: number\n    top: number\n    left: number\n    right: number\n    bottom: number\n}\n\ninterface Props {\n    children: React.ReactElement\n    isPresent: boolean\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n    pop?: boolean\n}\n\ninterface MeasureProps extends Props {\n    childRef: React.RefObject<HTMLElement | null>\n    sizeRef: React.RefObject<Size>\n}\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component<MeasureProps> {\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const element = this.props.childRef.current\n        if (element && prevProps.isPresent && !this.props.isPresent && this.props.pop !== false) {\n            const parent = element.offsetParent\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0\n            const parentHeight = isHTMLElement(parent)\n                ? parent.offsetHeight || 0\n                : 0\n\n            const size = this.props.sizeRef.current!\n            size.height = element.offsetHeight || 0\n            size.width = element.offsetWidth || 0\n            size.top = element.offsetTop\n            size.left = element.offsetLeft\n            size.right = parentWidth - size.width - size.left\n            size.bottom = parentHeight - size.height - size.top\n        }\n\n        return null\n    }\n\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() {}\n\n    render() {\n        return this.props.children\n    }\n}\n\nexport function PopChild({ children, isPresent, anchorX, anchorY, root, pop }: Props) {\n    const id = useId()\n    const ref = useRef<HTMLElement>(null)\n    const size = useRef<Size>({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n    })\n    const { nonce } = useContext(MotionConfigContext)\n    /**\n     * In React 19, refs are passed via props.ref instead of element.ref.\n     * We check props.ref first (React 19) and fall back to element.ref (React 18).\n     */\n    const childRef =\n        (children.props as { ref?: React.Ref<HTMLElement> })?.ref ??\n        (children as unknown as { ref?: React.Ref<HTMLElement> })?.ref\n    const composedRef = useComposedRefs(ref, childRef)\n\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right, bottom } = size.current\n        if (isPresent || pop === false || !ref.current || !width || !height) return\n\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`\n        const y = anchorY === \"bottom\" ? `bottom: ${bottom}` : `top: ${top}`\n\n        ref.current.dataset.motionPopId = id\n\n        const style = document.createElement(\"style\")\n        if (nonce) style.nonce = nonce\n\n        const parent = root ?? document.head\n        parent.appendChild(style)\n\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            ${y}px !important;\n          }\n        `)\n        }\n\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style)\n            }\n        }\n    }, [isPresent])\n\n    return (\n        <PopChildMeasure isPresent={isPresent} childRef={ref} sizeRef={size} pop={pop}>\n            {pop === false\n                ? children\n                : React.cloneElement(children as any, { ref: composedRef })}\n        </PopChildMeasure>\n    )\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAgCA;;;CAGG,GACH,MAAA,wBAAA,kNAAA;IACI,wBAAA,SAAA,EAAA;;;YAGQ,MAAA,SAAA,QAAA,YAAA;YACA,MAAA,cAAA,IAAA,+LAAA,EAAA,UACI,OAAA,WAAA,IAAA;YAEJ,MAAA,eAAA,IAAA,+LAAA,EAAA,UACI,OAAA,YAAA,IAAA;;;;YAMJ,KAAA,GAAA,GAAA,QAAA,SAAA;YACA,KAAA,IAAA,GAAA,QAAA,UAAA;YACA,KAAA,KAAA,GAAA,cAAA,KAAA,KAAA,GAAA,KAAA,IAAA;YACA,KAAA,MAAA,GAAA,eAAA,KAAA,MAAA,GAAA,KAAA,GAAA;;QAGJ,OAAA;;IAGJ;;KAEG,GACH,qBAAA,CAAA;;QAGI,OAAA,IAAA,CAAA,KAAA,CAAA,QAAA;;AAEP;AAEe,SAAA,SAAA,EAAA,QAAA,EAAA,SAAA,EAAA,OAAA,EAAA,OAAA,EAAA,IAAA,EAAA,GAAA,EAAA;IACZ,MAAA,KAAA,IAAA,8MAAA;IACA,MAAA,MAAA,IAAA,+MAAA,EAAA;;QAEI,OAAA;QACA,QAAA;QACA,KAAA;QACA,MAAA;QACA,OAAA;QACA,QAAA;IACH;;IAED;;;KAGG,GACH,MAAA,WAAA,SAAA,KAAA,EAAA;;IAKA;;;;;;;;KAQG;QAEC,MAAA,EAAA,KAAA,EAAA,MAAA,EAAA,GAAA,EAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,GAAA,KAAA,OAAA;QACA,IAAA,aAAA,QAAA,SAAA,CAAA,IAAA,OAAA,IAAA,CAAA,SAAA,CAAA;QAEA,MAAA,IAAA,YAAA,SAAA,CAAA,MAAA,EAAA,MAAA,GAAA,CAAA,OAAA,EAAA,OAAA;QACA,MAAA,IAAA,YAAA,WAAA,CAAA,QAAA,EAAA,QAAA,GAAA,CAAA,KAAA,EAAA,KAAA;;;QAKA,IAAA,OAAW,MAAA,KAAA,GAAA;QAEX,MAAA,SAAA,QAAA,SAAA,IAAA;QACA,OAAA,WAAA,CAAA;QAEA,IAAA,MAAA,KAAA,EAAA;YACI,MAAA,KAAA,CAAA,UAAA,CAAA,CAAA;;;;;;;;QAQH,CAAA;;QAGD,OAAA;YACI,IAAA,OAAA,QAAA,CAAA,QAAA;gBACI,OAAA,WAAA,CAAA;;QAER;IACJ,GAAA;QAAA;KAAA;;;;;;kCAKY,WACA,qNAAA,CAAA,UAAA;YAAA,KAAA;QAAA;IAAA;AAGhB"}},
    {"offset": {"line": 646, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","sources":["file:///D:/Pivot%20Hackathon/l-T-SRCAS-hack/node_modules/framer-motion/src/components/AnimatePresence/PresenceChild.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { useId, useMemo } from \"react\"\nimport {\n    PresenceContext,\n    type PresenceContextProps,\n} from \"../../context/PresenceContext\"\nimport { VariantLabels } from \"../../motion/types\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { PopChild } from \"./PopChild\"\n\ninterface PresenceChildProps {\n    children: React.ReactElement\n    isPresent: boolean\n    onExitComplete?: () => void\n    initial?: false | VariantLabels\n    custom?: any\n    presenceAffectsLayout: boolean\n    mode: \"sync\" | \"popLayout\" | \"wait\"\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n}\n\nexport const PresenceChild = ({\n    children,\n    initial,\n    isPresent,\n    onExitComplete,\n    custom,\n    presenceAffectsLayout,\n    mode,\n    anchorX,\n    anchorY,\n    root\n}: PresenceChildProps) => {\n    const presenceChildren = useConstant(newChildrenMap)\n    const id = useId()\n\n    let isReusedContext = true\n    let context = useMemo((): PresenceContextProps => {\n        isReusedContext = false\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId: string) => {\n                presenceChildren.set(childId, true)\n\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete) return // can stop searching when any is incomplete\n                }\n\n                onExitComplete && onExitComplete()\n            },\n            register: (childId: string) => {\n                presenceChildren.set(childId, false)\n                return () => presenceChildren.delete(childId)\n            },\n        }\n    }, [isPresent, presenceChildren, onExitComplete])\n\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context }\n    }\n\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false))\n    }, [isPresent])\n\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete()\n    }, [isPresent])\n\n    children = (\n        <PopChild pop={mode === \"popLayout\"} isPresent={isPresent} anchorX={anchorX} anchorY={anchorY} root={root}>\n            {children}\n        </PopChild>\n    )\n\n    return (\n        <PresenceContext.Provider value={context}>\n            {children}\n        </PresenceContext.Provider>\n    )\n}\n\nfunction newChildrenMap(): Map<string, boolean> {\n    return new Map()\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAyBa,MAAA,gBAAA,CAAA,EAAA,QAAA,EAAA,OAAA,EAAA,SAAA,EAAA,cAAA,EAAA,MAAA,EAAA,qBAAA,EAAA,IAAA,EAAA,OAAA,EAAA,OAAA,EAAA,IAAA,EAAA;IAYT,MAAA,mBAAA,IAAA,0LAAA,EAAA;IACA,MAAA,KAAA,IAAA,8MAAA;;IAGA,IAAA,UAAA,IAAA,gNAAA,EAAA;;;;;;;YAOQ,gBAAA,CAAA;gBACI,iBAAA,GAAA,CAAA,SAAA;;oBAGI,IAAA,CAAA,YAAiB,QAAA,4CAAA;;;;YAKzB,UAAA,CAAA;gBACI,iBAAA,GAAA,CAAA,SAAA;;;;;;;;;IAMZ;;;;KAIG,GACH,IAAA,yBAAA,iBAAA;QACI,UAAA;YAAA,GAAA,OAAA;QAAA;;;QAIA,iBAAA,OAAA,CAAA,CAAA,GAAA,MAAA,iBAAA,GAAA,CAAA,KAAA;IACJ,GAAA;QAAA;KAAA;IAEA;;;KAGG,GACH,kNAAA,CAAA;QACI,CAAA,yDAGI;IACR,GAAA;QAAA;KAAA;IAEA,WAAA,IAAA,8NAAA,EAAA,wMAAA,EAAA;QAAA,KAAA,SAAA;QAAA,WAAA;QAAA,SAAA;QAAA,SAAA;QAAA,MAAA;QAAA,UAAA;IAAA;IAMA,OAAA,IAAA,8NAAA,EAAA,gMAAA,CAAA,QAAA,EAAA;QAAA,OAAA;QAAA,UAAA;IAAA;AAKJ;AAEA,SAAA;;AAEA"}},
    {"offset": {"line": 734, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs","sources":["file:///D:/Pivot%20Hackathon/l-T-SRCAS-hack/node_modules/framer-motion/src/components/AnimatePresence/utils.ts"],"sourcesContent":["import { isValidElement, Children, ReactElement, ReactNode } from \"react\"\n\nexport type ComponentKey = string | number\n\nexport const getChildKey = (child: ReactElement<any>): ComponentKey =>\n    child.key || \"\"\n\nexport function onlyElements(children: ReactNode): ReactElement<any>[] {\n    const filtered: ReactElement<any>[] = []\n\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child)) filtered.push(child)\n    })\n\n    return filtered\n}\n"],"names":[],"mappings":";;;;;;;;AAIO,MAAM,WAAW,GAAG,CAAC,KAAwB,GAChD,KAAK,CAAC,GAAG,IAAI,GAAE;AAEb,SAAU,YAAY,CAAC,QAAmB,EAAA;IAC5C,MAAM,QAAQ,GAAwB,EAAE,CAAA;;IAGxC,iNAAQ,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,KAAI;QACjC,QAAI,uNAAc,EAAC,KAAK,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;IACnD,CAAC,CAAC,CAAA;IAEF,OAAO,QAAQ,CAAA;AACnB"}},
    {"offset": {"line": 757, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","sources":["file:///D:/Pivot%20Hackathon/l-T-SRCAS-hack/node_modules/framer-motion/src/components/AnimatePresence/index.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { useContext, useMemo, useRef, useState } from \"react\"\nimport { LayoutGroupContext } from \"../../context/LayoutGroupContext\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { useIsomorphicLayoutEffect } from \"../../utils/use-isomorphic-effect\"\nimport { PresenceChild } from \"./PresenceChild\"\nimport { AnimatePresenceProps } from \"./types\"\nimport { usePresence } from \"./use-presence\"\nimport { ComponentKey, getChildKey, onlyElements } from \"./utils\"\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nexport const AnimatePresence = ({\n    children,\n    custom,\n    initial = true,\n    onExitComplete,\n    presenceAffectsLayout = true,\n    mode = \"sync\",\n    propagate = false,\n    anchorX = \"left\",\n    anchorY = \"top\",\n    root\n}: React.PropsWithChildren<AnimatePresenceProps>) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate)\n\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children])\n\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys =\n        propagate && !isParentPresent ? [] : presentChildren.map(getChildKey)\n\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true)\n\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren)\n\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map<ComponentKey, boolean>())\n\n    /**\n     * Track which components are currently processing exit to prevent duplicate processing.\n     */\n    const exitingComponents = useRef(new Set<ComponentKey>())\n\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren)\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren)\n\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false\n        pendingPresentChildren.current = presentChildren\n\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i])\n\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false)\n                }\n            } else {\n                exitComplete.delete(key)\n                exitingComponents.current.delete(key)\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")])\n\n    const exitingChildren: any[] = []\n\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren]\n\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i]\n            const key = getChildKey(child)\n\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child)\n                exitingChildren.push(child)\n            }\n        }\n\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren\n        }\n\n        setRenderedChildren(onlyElements(nextChildren))\n        setDiffedChildren(presentChildren)\n\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null\n    }\n\n    if (\n        process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1\n    ) {\n        console.warn(\n            `You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`\n        )\n    }\n\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext)\n\n    return (\n        <>\n            {renderedChildren.map((child) => {\n                const key = getChildKey(child)\n\n                const isPresent =\n                    propagate && !isParentPresent\n                        ? false\n                        : presentChildren === renderedChildren ||\n                          presentKeys.includes(key)\n\n                const onExit = () => {\n                    if (exitingComponents.current.has(key)) {\n                        return\n                    }\n                    exitingComponents.current.add(key)\n\n                    if (exitComplete.has(key)) {\n                        exitComplete.set(key, true)\n                    } else {\n                        return\n                    }\n\n                    let isEveryExitComplete = true\n                    exitComplete.forEach((isExitComplete) => {\n                        if (!isExitComplete) isEveryExitComplete = false\n                    })\n\n                    if (isEveryExitComplete) {\n                        forceRender?.()\n                        setRenderedChildren(pendingPresentChildren.current)\n\n                        propagate && safeToRemove?.()\n\n                        onExitComplete && onExitComplete()\n                    }\n                }\n\n                return (\n                    <PresenceChild\n                        key={key}\n                        isPresent={isPresent}\n                        initial={\n                            !isInitialRender.current || initial\n                                ? undefined\n                                : false\n                        }\n                        custom={custom}\n                        presenceAffectsLayout={presenceAffectsLayout}\n                        mode={mode}\n                        root={root}\n                        onExitComplete={isPresent ? undefined : onExit}\n                        anchorX={anchorX}\n                        anchorY={anchorY}\n                    >\n                        {child}\n                    </PresenceChild>\n                )\n            })}\n        </>\n    )\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCG,GACU,MAAA,kBAAA,CAAA,EAAA,QAAA,EAAA,MAAA,EAAA,UAAA,IAAA,EAAA,cAAA,EAAA,wBAAA,IAAA,EAAA,OAAA,MAAA,EAAA,YAAA,KAAA,EAAA,UAAA,MAAA,EAAA,UAAA,KAAA,EAAA,IAAA,EAAA;;IAcT;;;KAGG,GACH,MAAA,kBAAA,IAAA,gNAAA,EAAA,IAAA,IAAA,yMAAA,EAAA,WAAA;QAAA;KAAA;IAEA;;;KAGG,GACH,MAAA,cAAA,aAAA,CAAA,kBAAA,EAAA,GAAA,gBAAA,GAAA,CAAA,wMAAA;IAGA;;KAEG,GACH,MAAA,kBAAA,IAAA,+MAAA,EAAA;IAEA;;;;KAIG,GACH,MAAA,yBAAA,IAAA,+MAAA,EAAA;IAEA;;KAEG;IAGH;;KAEG;IAGH;;;KAGG;;;QAKC,gBAAA,OAAA,GAAA;QACA,uBAAA,OAAA,GAAA;QAEA;;SAEG,GACH,IAAA,IAAA,IAAA,GAAA,IAAA,iBAAA,MAAA,EAAA,IAAA;;;;oBAKY,aAAA,GAAA,CAAA,KAAA;;;gBAGJ,aAAA,MAAA,CAAA;gBACA,kBAAA,OAAA,CAAA,MAAA,CAAA;;;IAGZ,GAAA;QAAA;QAAA,YAAA,MAAA;QAAA,YAAA,IAAA,CAAA;KAAA;;IAIA,IAAA,oBAAA,gBAAA;QACI,IAAA,eAAA;eAAA;SAAA;QAEA;;;SAGG,GACH,IAAA,IAAA,IAAA,GAAA,IAAA,iBAAA,MAAA,EAAA,IAAA;YACI,MAAA,QAAA,gBAAA,CAAA,EAAA;YACA,MAAA,MAAA,IAAA,wMAAA,EAAA;;;gBAII,gBAAA,IAAA,CAAA;;;QAIR;;;SAGG;;;QAKH,oBAAA,IAAA,yMAAA,EAAA;;QAGA;;;SAGG,GACH,OAAA;;IAGJ,IAAA,oDAAA,gBAEI,SAAA,UACA,iBAAA,MAAA,GAAA,GAAA;QAEA,QAAA,IAAA,CAAA,CAAA,6IAAA,CAAA;;IAKJ;;;;KAIG;;;YAMS,MAAA,MAAA,IAAA,wMAAA,EAAA;YAEA,MAAA,YAAA,aAAA,CAAA,kBAEQ,gDAEE,YAAA,QAAA,CAAA;;;;;gBAMN,kBAAA,OAAA,CAAA,GAAA,CAAA;gBAEA,IAAA,aAAA,GAAA,CAAA,MAAA;oBACI,aAAA,GAAA,CAAA,KAAA;;;;;gBAMJ,aAAA,OAAA,CAAA,CAAA;oBACI,IAAA,CAAA;gBACJ;;;oBAII,oBAAA,uBAAA,OAAA;oBAEA,aAAA;;;YAIR;YAEA,OAAA,IAAA,8NAAA,EAAA,kNAAA,EAAA;gBAAA,WAAA;gBAAA,SAAA,CAAA,gBAAA,OAAA,IAAA,UAMgB;;;;;;;;;;;;AAiBhC"}}]
}